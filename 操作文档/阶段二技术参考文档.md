# 阶段二技术参考文档

## 系统架构

### 核心组件架构
```
WallExtractionManager (管理器)
├── LineDrawingTool (线段绘制工具)
├── WallFittingAlgorithm (墙面拟合算法)
├── WireframeGenerator (线框生成器)
├── UIIntegrationHelper (UI集成助手)
├── WallFittingProgressDialog (进度对话框)
└── WallFittingResultDialog (结果对话框)
```

### 数据流架构
```
点云数据 → 空间索引 → RANSAC算法 → 平面检测 → 墙面提取 → 结果输出
     ↓
用户线段 → 线段处理 → 约束拟合 → 几何优化 → 质量评估 → 结果验证
```

## RANSAC墙面拟合算法

### 算法原理

#### 1. 基本RANSAC流程
```cpp
for (int iteration = 0; iteration < maxIterations; ++iteration) {
    // 1. 随机选择3个点构成平面
    auto samplePoints = randomSample(points, 3);
    
    // 2. 计算平面方程 ax + by + cz + d = 0
    Plane3D plane = fitPlane(samplePoints);
    
    // 3. 计算所有点到平面的距离
    auto inliers = findInliers(points, plane, distanceThreshold);
    
    // 4. 如果内点数量足够多，更新最佳平面
    if (inliers.size() > bestInlierCount) {
        bestPlane = plane;
        bestInlierCount = inliers.size();
    }
}
```

#### 2. 垂直平面过滤
```cpp
bool isVerticalPlane(const Plane3D& plane) {
    QVector3D normal = plane.normal.normalized();
    float verticalThreshold = 0.1f; // cos(84°) ≈ 0.1
    return qAbs(normal.z()) < verticalThreshold;
}
```

#### 3. 平面聚类合并
```cpp
std::vector<Plane3D> clusterPlanes(const std::vector<Plane3D>& planes) {
    const float angleThreshold = 5.0f; // 度
    const float distanceThreshold = 0.2f; // 米
    
    // 使用层次聚类算法合并相似平面
    return hierarchicalClustering(planes, angleThreshold, distanceThreshold);
}
```

### 关键参数说明

#### RANSAC参数
| 参数 | 默认值 | 说明 | 调整建议 |
|------|--------|------|----------|
| probability | 0.99 | 算法成功概率 | 高精度要求：0.999，快速处理：0.95 |
| maxIterations | 1000 | 最大迭代次数 | 复杂场景：2000-5000，简单场景：500 |
| distanceThreshold | 0.1 | 点到平面距离阈值(米) | 高密度点云：0.05，低密度：0.15-0.2 |
| minPoints | 50 | 平面最小内点数 | 大场景：100-200，小场景：20-30 |

#### 几何过滤参数
| 参数 | 默认值 | 说明 | 调整建议 |
|------|--------|------|----------|
| verticalAngleThreshold | 84° | 垂直平面角度阈值 | 严格：80°，宽松：88° |
| minWallLength | 0.5 | 最小墙面长度(米) | 大建筑：1.0，小房间：0.3 |
| maxWallThickness | 0.5 | 最大墙面厚度(米) | 厚墙：0.8，薄墙：0.3 |
| parallelAngleThreshold | 5° | 平行墙面角度阈值 | 严格：3°，宽松：10° |

### 算法性能分析

#### 时间复杂度
- **RANSAC主循环**：O(k × n)，k为迭代次数，n为点数
- **平面拟合**：O(1)，固定3点计算
- **内点查找**：O(n)，遍历所有点
- **平面聚类**：O(m²)，m为平面数量
- **总体复杂度**：O(k × n + m²)

#### 空间复杂度
- **点云存储**：O(n)
- **平面存储**：O(m)
- **索引结构**：O(n)（八叉树或KD树）
- **总体复杂度**：O(n + m)

#### 性能优化策略
1. **空间索引**：使用八叉树加速邻域查询
2. **早期终止**：达到期望内点数时提前结束
3. **分层处理**：大数据集分块处理
4. **并行计算**：多线程并行RANSAC

## 线段绘制系统

### 数据结构设计

#### LineSegment类
```cpp
class LineSegment {
private:
    int m_id;                    // 唯一标识符
    QVector3D m_startPoint;      // 起点坐标
    QVector3D m_endPoint;        // 终点坐标
    QColor m_color;              // 显示颜色
    float m_width;               // 线宽
    bool m_selected;             // 选中状态
    
public:
    float length() const;        // 计算长度
    QVector3D direction() const; // 计算方向向量
    QVector3D midpoint() const;  // 计算中点
    float distanceToPoint(const QVector3D& point) const; // 点到线段距离
};
```

#### PolylineChain类
```cpp
class PolylineChain {
private:
    std::vector<QVector3D> m_points;     // 顶点序列
    std::vector<LineSegment> m_segments; // 线段序列
    bool m_closed;                       // 是否闭合
    
public:
    void addPoint(const QVector3D& point);           // 添加顶点
    void insertPoint(int index, const QVector3D& point); // 插入顶点
    void removePoint(int index);                     // 删除顶点
    std::vector<LineSegment> getSegments() const;    // 获取所有线段
};
```

### 交互处理机制

#### 鼠标事件处理
```cpp
void LineDrawingTool::mousePressEvent(QMouseEvent* event) {
    QVector3D worldPos = screenToWorld(event->pos());
    
    switch (m_currentMode) {
        case DrawingMode::SingleLine:
            handleSingleLinePress(worldPos);
            break;
        case DrawingMode::Polyline:
            handlePolylinePress(worldPos);
            break;
        case DrawingMode::Selection:
            handleSelectionPress(worldPos);
            break;
        case DrawingMode::Editing:
            handleEditingPress(worldPos);
            break;
    }
}
```

#### 坐标转换
```cpp
QVector3D LineDrawingTool::screenToWorld(const QPoint& screenPos) {
    // 屏幕坐标转世界坐标
    QMatrix4x4 viewMatrix = getViewMatrix();
    QMatrix4x4 projMatrix = getProjectionMatrix();
    QRect viewport = getViewport();
    
    return screenPos.unproject(viewMatrix * projMatrix, viewport);
}
```

### 渲染系统

#### OpenGL渲染管线
```cpp
void LineDrawingTool::render() {
    // 1. 设置渲染状态
    glEnable(GL_LINE_SMOOTH);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
    // 2. 渲染普通线段
    renderNormalLines();
    
    // 3. 渲染选中线段（高亮）
    renderSelectedLines();
    
    // 4. 渲染预览线段
    renderPreviewLine();
    
    // 5. 恢复渲染状态
    glDisable(GL_BLEND);
    glDisable(GL_LINE_SMOOTH);
}
```

#### 着色器程序
```glsl
// 顶点着色器
#version 330 core
layout (location = 0) in vec3 position;
uniform mat4 mvpMatrix;

void main() {
    gl_Position = mvpMatrix * vec4(position, 1.0);
}

// 片段着色器
#version 330 core
uniform vec4 lineColor;
out vec4 fragColor;

void main() {
    fragColor = lineColor;
}
```

## 数据持久化

### JSON数据格式

#### 线段数据格式
```json
{
    "version": "1.0",
    "timestamp": "2024-01-01T12:00:00Z",
    "coordinate_system": "local",
    "line_segments": [
        {
            "id": 1,
            "start_point": [0.0, 0.0, 0.0],
            "end_point": [5.0, 0.0, 0.0],
            "color": [0, 0, 255, 255],
            "width": 2.0,
            "properties": {
                "length": 5.0,
                "angle": 0.0,
                "type": "wall_outline"
            }
        }
    ],
    "polylines": [
        {
            "id": 1,
            "points": [
                [0.0, 0.0, 0.0],
                [5.0, 0.0, 0.0],
                [5.0, 3.0, 0.0],
                [0.0, 3.0, 0.0]
            ],
            "closed": true,
            "properties": {
                "total_length": 16.0,
                "area": 15.0,
                "type": "room_boundary"
            }
        }
    ]
}
```

#### 墙面结果格式
```json
{
    "version": "1.0",
    "algorithm": "RANSAC",
    "parameters": {
        "probability": 0.99,
        "max_iterations": 1000,
        "distance_threshold": 0.1,
        "min_points": 50
    },
    "statistics": {
        "total_points": 100000,
        "processed_points": 95000,
        "unassigned_points": 5000,
        "processing_time": 12.5,
        "wall_count": 4,
        "plane_count": 6
    },
    "walls": [
        {
            "id": 1,
            "start_point": [0.0, 0.0, 0.0],
            "end_point": [5.0, 0.0, 0.0],
            "normal": [0.0, 1.0, 0.0],
            "height": 2.8,
            "thickness": 0.2,
            "confidence": 0.95,
            "inlier_count": 1250,
            "properties": {
                "length": 5.0,
                "area": 14.0,
                "type": "exterior_wall"
            }
        }
    ],
    "planes": [
        {
            "id": 1,
            "normal": [0.0, 1.0, 0.0],
            "distance": 2.5,
            "inlier_indices": [100, 101, 102, ...],
            "confidence": 0.95,
            "type": "vertical"
        }
    ]
}
```

## 性能监控和调试

### 性能指标

#### 关键性能指标(KPI)
- **处理速度**：点/秒
- **内存使用**：峰值内存占用
- **准确率**：正确检测的墙面比例
- **召回率**：检测到的墙面占实际墙面的比例
- **处理时间**：总处理时间和各阶段时间

#### 性能监控代码
```cpp
class PerformanceMonitor {
private:
    std::chrono::high_resolution_clock::time_point m_startTime;
    std::map<std::string, double> m_timings;
    size_t m_peakMemoryUsage;
    
public:
    void startTiming(const std::string& operation);
    void endTiming(const std::string& operation);
    void recordMemoryUsage();
    void generateReport();
};
```

### 调试工具

#### 日志系统
```cpp
// 日志级别定义
enum class LogLevel {
    Debug,    // 详细调试信息
    Info,     // 一般信息
    Warning,  // 警告信息
    Error,    // 错误信息
    Critical  // 严重错误
};

// 日志宏定义
#define LOG_DEBUG(msg) Logger::instance().log(LogLevel::Debug, msg)
#define LOG_INFO(msg) Logger::instance().log(LogLevel::Info, msg)
#define LOG_WARNING(msg) Logger::instance().log(LogLevel::Warning, msg)
#define LOG_ERROR(msg) Logger::instance().log(LogLevel::Error, msg)
```

#### 可视化调试
```cpp
class DebugRenderer {
public:
    void renderPoints(const std::vector<QVector3D>& points, const QColor& color);
    void renderPlane(const Plane3D& plane, const QColor& color);
    void renderBoundingBox(const QVector3D& min, const QVector3D& max);
    void renderNormals(const std::vector<QVector3D>& points, 
                      const std::vector<QVector3D>& normals);
};
```

## 扩展和定制

### 算法扩展接口
```cpp
class WallFittingAlgorithmInterface {
public:
    virtual ~WallFittingAlgorithmInterface() = default;
    virtual WallFittingResult fitWalls(const std::vector<QVector3D>& points) = 0;
    virtual void setParameters(const AlgorithmParameters& params) = 0;
    virtual std::string getAlgorithmName() const = 0;
};
```

### 插件系统架构
```cpp
class PluginManager {
public:
    void loadPlugin(const QString& pluginPath);
    void unloadPlugin(const QString& pluginName);
    std::vector<QString> getAvailableAlgorithms() const;
    WallFittingAlgorithmInterface* createAlgorithm(const QString& name);
};
```

### 自定义参数配置
```cpp
class ParameterManager {
public:
    void loadParameters(const QString& configFile);
    void saveParameters(const QString& configFile);
    void setParameter(const QString& name, const QVariant& value);
    QVariant getParameter(const QString& name) const;
    void resetToDefaults();
};
```

## 质量保证

### 单元测试框架
```cpp
class WallFittingAlgorithmTest : public QObject {
    Q_OBJECT
    
private slots:
    void testRANSACBasicFunctionality();
    void testVerticalPlaneFiltering();
    void testPlaneClusteringMerging();
    void testPerformanceWithLargeDataset();
    void testParameterSensitivity();
};
```

### 集成测试
```cpp
class IntegrationTest : public QObject {
    Q_OBJECT
    
private slots:
    void testCompleteWorkflow();
    void testUIIntegration();
    void testDataPersistence();
    void testErrorHandling();
};
```

### 性能基准测试
```cpp
class BenchmarkTest {
public:
    void benchmarkRANSACPerformance();
    void benchmarkMemoryUsage();
    void benchmarkRenderingPerformance();
    void generatePerformanceReport();
};
```

---

**本文档提供了阶段二功能的完整技术参考，包括算法原理、系统架构、性能优化等方面的详细信息。开发者可以基于此文档进行功能扩展和性能调优。**
